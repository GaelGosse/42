#!/bin/sh

# part test
function t1()
{
	# see all the args
	for var in "$@"
	do
		echo "$var"
	done
}

function t2()
{
	a="some long string"
    b="ri"
	# return the rest of the occurence
	echo $a | grep -o "$b.*"
}

function t3()
{
	# get args after the second
	echo "${@:2}"
	# get args after the third
	echo "${@:3}"
}

function t4()
{
	# get nbr of args
	echo "$#"
}

function t5()
{
	# check if there is something like "- * s"
	str="-ms"
	a1="${str/e}"
	a2="${str/m}"
	if [ "${str/e}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
	if [ "${str/-*s}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
}

function t6()
{
	# check if there is something like "- * m" in the 1st arg
	if [[ "${1/-*m}" != $1 ]]; then
		echo "there is m"
	else
		echo "nothing"
	fi
}

function t7()
{
	echo "${BASH_SOURCE}"
	echo "${BASH_SOURCE}"
}

function t8()
{
	if [ -z "$1" ]
	then
		echo "No argument suppliedwith" '$1'
	fi
}

function t9()
{
	tmp='%u'
	tmp='%n@%m'
	echo "$tmp"
	# echo ${(%)tmp}
	
	# bash
	# tmp=$(set +x; (PS4='+.\u@\h'; set -x; :) 2>&1); tmp=${tmp#*.}; echo ${tmp%:}
}

function t10()
{
	# SPLIT

	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$text"

	#Count the total words
	echo "There are ${#strarr[*]} words in the text."

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
	printf "$val\n"
	done
}

# google-chrome-stable https://pythontutor.com/c.html#mode=edit

function t11()
{
	if test -f "*.c"; then
		echo "ok"
	else
		echo "nothing"
	fi
}

function t12()
{
	FILES="/bin/*"
	for file in /mnt/nfs/homes/ggosse/42/*
	do
		dir="$(dirname "${file}")"
		filename="$(basename "${file}")"
		if [[ -f $file ]]; then
			echo -e "$GREEN /$filename"
		elif [[ -d $file ]]; then
			echo -e "$CYAN /$filename"
		else
			echo -e "$YELLOW /$filename"
		fi
	done
}
 
function t13()
{
	each file
	for file in "$/."; do
		if [ -d $file ]
		then
				# do something directory-ish
		else
				if [ "$file" == "*.txt" ]       #  this is the snag
				then
						# do something txt-ish
				fi
		fi
	done;
}

#
function t14()
{
	FILES="/mnt/nfs/homes/ggosse/42/cursus/gnl/*"
	for filename in /mnt/nfs/homes/ggosse/42/cursus/gnl/*; do
		echo -e "$CYAN here $filename";
	done
}

# call multiple web page
function t15()
{
	a=1
	while true; do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$a/fr.subject.pdf
		let "a+=1"
		if [[ $a > 10 ]]; then
			break;
		fi
	done
}

function t16()
{
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/1/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/2/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/3/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/4/fr.subject.pdf
	start=57300
	step=20

	let "end=$start+$step-1"
	for i in {$start..$end}
	do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$i/fr.subject.pdf
		let "i+=1"
	done
}





function t17()
{
	if [[ $# > 1 ]]
	then
		echo -ne "echo "
		echo -e $RED"something for example$RST"
		echo -e 'last return        : $_     ' $_
		echo -e 'return value       : $?     ' $?
		echo -e 'first argument     : $1     ' $1
		echo -e 'second argument    : $2     ' $2
		echo -e 'all of argument    : $@     ' $@
		echo -e 'number of argument : $#     ' $#
		echo -e 'EUID               : ${EUID} '${EUID}
	else
		echo $RTRE
	fi
}


# SPLIT
function t18()
{
	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	# IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$1"

	#Count the total words
	echo -e "$CYAN${#strarr[*]}$RST"
	echo -e "$RED${strarr[*]}$RST"

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
		printf "$val\n"
	done
}

# catch a sigint
function t19()
{
	trap 'echo -e "\nhey"' INT
	# for ((n=20; n; n--))
	# do
	# 	sleep $SLEEP
	# done
}

# open vscode after a grep in a certain file and line number
function t20()
{
	# r recursive ins subfolder
	# i insensitive case
	# n at number line xxx
	# o word exact match 
	if [[ $# == 1 ]]; then
		result=`grep -rinl $1 --exclude-dir=node_modules`
		# echo $result
		read -a arr <<< "$result"
		echo $arr | '{gsup($1,'')}'
		# code $arr 
		# echo -e "$RED${arr[*]}$RST"
		# echo -e "$CYAN${#arr[*]}$RST"
		# for val in "${arr[@]}";
		# do
		# 	printf "$val\n"
		# done
	else
		printf "something wrong"
	fi
}

# test	is in	in a condition
function t21()
{
	# if [[ is_in ]]; then
	# 	echo "a"
	# else
	# 	echo "b"
	# fi
	echo "not finish"
}

# call multiple times a bash function
function t22 ()
{

	# start=1
	# end=20

	# for i in {1..7}
	# do
	# 	print_title "GNL" $i
	# 	let "i+=1"
	# done

	print_title "GNL" 7 # Red
	print_title "GNL" 3 # Green
	print_title "GNL" 4 # Yellow
	print_title "GNL" 1 # Orange or Blue
	print_title "GNL" 5 # Blue
	print_title "GNL" 6 # Cyan
	print_title "GNL" 2 # White
}

function t23()
{
	arr=()
	arr+=("a")
	arr+=("b")
	arr+=("c")
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function t24()
{
	arr=("AC" "TV" "Mobile" "Fridge" "Oven" "Blender")
	arr+=("Dish Washer")
	arr+=("Cat")
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function t25()
{
	name_page=()
	answer=""
	echo "How many pages do you want ? (digits) "
	read answer
	if [[ $answer > 0 || $answer < 31 ]]
	then
		if [[ $1 == "1" ]]
		then
			name_page+="one"
		else
			echo "name each page"
			start=1
			for ((n=1; n<=$answer; n++))
			do
				echo "	page $n = ... ?"
				read a
				name_page+=($a)
			done
		fi
		# for item in "${name_page[@]}"
		# do
		# 	echo $item
		# done
	else
		echo "error: $answer is not a number or dot not belongs to this interval [1..30]";
	fi
}

function t26()
{
	# REPLACE A CHAR BY ANOTHER IN A STRING
	item="browser-refresh"
	echo $item
	var_name=$(echo "$item" | tr - _)
	echo $var_name
}

function t27()
{
	item='exemple'
	home_page="${item}"
	echo $home_page
}

function t28()
{
	# test if args exist
	if [ $# -eq 0 ]
	then
		echo "No arguments supplied with" '$#'

	fi

	# test if arg 2 exist
	if [ -z "$1" ]
	then
		echo "first arg missing"
	fi
}

function t29()
{
	# - Position the Cursor:
	# \033[<L>;<C>H
	# 	Or
	# \033[<L>;<C>f
	# puts the cursor at line L and column C.
	# - Move the cursor up N lines:
	# \033[<N>A
	# - Move the cursor down N lines:
	# \033[<N>B
	# - Move the cursor forward N columns:
	# \033[<N>C
	# - Move the cursor backward N columns:
	# \033[<N>D

	# - Clear the screen, move to (0,0):
	# \033[2J
	# - Erase to end of line:
	# \033[K

	# - Save cursor position:
	# \033[s
	# - Restore cursor position:
	# \033[u

	# echo -e "\033[<5>B X"
	# echo -en "\033[s\033[7B\033[1;34m 7 lines down violet \033[u\033[0m"
	# echo -en "\033[s\033[7A\033[1;32m 7 lines up green \033[u\033[0m"	

	tput clear      # clear the screen

	tput cup 3 15   # Move cursor to screen location X,Y (top left is 0,0)

	tput setaf 3    # Set a foreground colour using ANSI escape
	echo "XYX Corp LTD."
	tput sgr0

	tput cup 5 17
	tput rev        # Set reverse video mode (background)
	echo " M A I N - M E N U "
	tput sgr0       # stop background color

	tput cup 7 15; echo "1. User Management"
	tput cup 8 15; echo "2. Service Management"
	tput cup 9 15; echo "3. Process Management"
	tput cup 10 15; echo "4. Backup"

	tput bold       # Set bold mode (red)
	tput cup 12 15
	read -p "Enter your choice [1-4] " choice

	tput clear
	tput sgr0
	tput rc
}

function t30()
{
	# get position of the cursor
	exec < /dev/tty
	oldstty=$(stty -g)
	stty raw -echo min 0
	# on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	# tput u7 > /dev/tty    # when TERM=xterm (and relatives)
	IFS=';' read -r -d R -a pos
	stty $oldstty
	# change from one-based to zero based so they work with: tput cup $row $col
	row=$((${pos[0]:2} - 1))    # strip off the esc-[
	col=$((${pos[1]} - 1))
	echo $row
	echo $col
}

function t31()
{
	perc=0
	
	sleep $SLEEP
	tput clear

	tput cup 0 0; echo "-"
	tput cup 0 8; echo "-"

	tput cup 0 10; echo "["

	tput setaf 1
	tput rev
	tput cup 0 11; echo "          "
	tput sgr0

	# tput setaf 1
	tput cup 0 21; echo "]"

	tput sgr0
	sleep $SLEEP
	while [[ $perc -lt 101 ]]
	do
		if [[ $perc -ge 0 && $perc -lt 10 ]]
		then
			tput cup 0 4; echo "$perc %"
		elif [[ $perc -ge 10 && $perc -lt 100 ]]
		then
			tput cup 0 3; echo "$perc %"
		else [[ $perc -ge 100 && $perc -lt 1000 ]]
			tput cup 0 2; echo "$perc %"
		fi
		if [[ $perc -lt 100 ]]
		then
			tput setaf 2
			tput rev
			tput cup 0 $((($perc/10)+11)); echo " "
			tput sgr0
		fi

		let "perc+=1"
		sleep 0.05
	done
}

function t32()
{
	HEIGHT=15
	WIDTH=40
	CHOICE_HEIGHT=4
	BACKTITLE="Backtitle here"
	TITLE="Title here"
	MENU="Choose one of the following options:"

	OPTIONS=(1 "Option 1"
			2 "Option 2"
			3 "Option 3")

	CHOICE=$(dialog --clear \
					--backtitle "$BACKTITLE" \
					--title "$TITLE" \
					--menu "$MENU" \
					$HEIGHT $WIDTH $CHOICE_HEIGHT \
					"${OPTIONS[@]}" \
					2>&1 >/dev/tty)

	case $CHOICE in
			1)
				echo "You chose Option 1"
				;;
			2)
				echo "You chose Option 2"
				;;
			3)
				echo "You chose Option 3"
				;;
	esac
}

function t33()
{
	text=$PATH
	IFS=':'
	read -a strarr <<< "$text"
	echo -e "length: ${#strarr[*]} \n"
	for val in "${strarr[@]}";
	do
		printf "$val\n"
	done
}

function t34()
{
	end=0
	result=$(top -bn1 | grep chrome | awk '{print $10}')
	# echo $result

	text=$(echo $result | tr '\n' ' ')
	echo $text 

	IFS=' '
	read -a strarr <<< "$text"
	echo -e "length: ${#strarr[*]} \n"
	for val in "${strarr[@]}";
	do
		# echo $end + $val
		end=$(echo $end + $val | bc)
		# printf "$end\n"
	done
	echo $end
}

function t35()
{
	grep -A 4 "$1"| grep -v "$1" | grep -v '^\d*$'
}



# m4 precompile header


#define malloc(...) NULL

#define prinT(str, __VA_ARG__)\
	#ifdef TEST\
		# printf(str, ##VA_ARG);\
	#endif\

# ðŸ’ðŸ´â€â˜ ðŸ–
# ðŸ´ â˜ ï¸
# ðŸ‘’âš”ðŸ´â€â˜ ï¸ðŸŒŠ
# ðŸ²
# ðŸ¦ˆ


# courses
function display_js()
{
	echo -e "$BACK_YELLOW   document   $RESET" "$BACK_WHITE""       .querySelector( $RESET" "$BACK_PURPLE    '#menu'     $RESET" "$BACK_WHITE) $RESET\n"
	echo -e "$RESET explained :"
	echo -e "$BACK_YELLOW the web page $RESET" "$BACK_WHITE"" .the search function( $RESET" "$BACK_PURPLE 'tag selector' $RESET" "$BACK_WHITE) $RESET"
	# event example and list
}

function display_port()
{
	echo -e "$BOLD_GREEN""IP address (format: $BOLD_YELLOW""x.x.x.x$BOLD_GREEN, x between $BOLD_YELLOW""0 and 255$BOLD_GREEN)"
	echo -e "$BOLD_CYAN        network id â”€â”´â”€â”˜$BOLD_PURPLE"" â””â”€â”´â”€ host id"
	echo -e "$GREEN""is a sequence of number that is connected to a computer network, used for communications."
	echo -e "2 main functions of am IP address: "
	echo -e "_ $BOLD_YELLOW""identification of a computer in a network$GREEN"
	echo -e "_ $BOLD_YELLOW""localisation of the computer$RESET"

	echo -e ""
	echo -e "$WHITE""CMD display port: $BOLD_WHITE""netstat -lntup"
	echo -e ""
	echo -e "$YELLOW""22    : $BOLD_GREEN""SSH$GREEN (Secure Shell)                           : $RESET"
	echo -e "$YELLOW""25    : $BOLD_GREEN""SMTP$GREEN (Simple Mail Transfer)                  : $RESET"
	echo -e "$YELLOW""143   : $BOLD_GREEN""IMAP$GREEN (Internet Message Access Protocol)      : $RESET"
	echo -e "$YELLOW""53    : $BOLD_GREEN""DNS$GREEN (Domain Name System)                     : use to identify computers through internet and associate Domain Name with other information$RESET"
	echo -e "$YELLOW""5353  : $BOLD_GREEN""mDNS$GREEN (multicast Domain Name System)          : $RESET"
	echo -e "$YELLOW""111   : $BOLD_GREEN""Portmapper$GREEN                                   : provides other ports where services are running$RESET"
	echo -e "$YELLOW""123   : $BOLD_GREEN""NTP$GREEN (Network Time Protocol)                  : use to $BOLD_YELLOW""synchronise clock$GREEN  between computer systems $RESET"
	echo -e "$YELLOW""80    : $BOLD_GREEN""HTTP$GREEN (HyperText Transfert Protocol)          : use to transfert hypermedia document (ex: HTML for $BOLD_YELLOW""website$GREEN)$RESET"
	echo -e "$YELLOW""443   : $BOLD_GREEN""HTTPS$GREEN (HyperText Transfert Protocol Secure)  : the same but it's $BOLD_YELLOW""encrypted with SSL$GREEN (so it use the HTTP)$RESET"
	echo -e "$YELLOW""631   : $BOLD_GREEN""IPP$GREEN (Internet Printing Protocol)             : use between clients devices and $BOLD_YELLOW""printers$RESET"
	echo -e ""
}

# refresh with a bash script
# function refresht()
# {
# 	interrupt="false"
# 	trap '$interrupt="true"' INT
# 	if [[ $# == 1 ]]; then
# 		source ~/.bashrc && $1
# 		echo -e "$BACK_CYAN ----- START ----- $RST"
# 		export TEST_FUNCTION=$1
# 		sleep $SLEEP
# 		refresht
# 	elif [[ $TEST_FUNCTION && $interrupt == "false" ]]; then
# 		source ~/.bashrc && $TEST_FUNCTION
# 		echo -e "$BACK_GREEN ----- IN TEST ----- $RST"
# 		sleep $SLEEP
# 		refresht
# 	fi
# }
