#!/bin/sh

# lite
export BLACK="\033[0;30m"
export RED="\033[0;31m"
export GREEN="\033[0;32m"
export YELLOW="\033[0;33m"
export BLUE="\033[0;34m"
export PURPLE="\033[0;35m"
export CYAN="\033[0;36m"
export WHITE="\033[0;37m"

# bold color
export BOLD_BLACK="\033[1;30m"
export BOLD_RED="\033[1;31m"
export BOLD_GREEN="\033[1;32m"
export BOLD_YELLOW="\033[1;33m"
export BOLD_BLUE="\033[1;34m"
export BOLD_PURPLE="\033[1;35m"
export BOLD_CYAN="\033[1;36m"
export BOLD_WHITE="\033[1;37m"

# background
export BACK_BLACK="\033[0;40m"
export BACK_RED="\033[0;41;30m"
export BACK_GREEN="\033[0;42;30m"
export BACK_YELLOW="\033[0;43;30m"
export BACK_BLUE="\033[0;44;30m"
export BACK_PURPLE="\033[0;45;37m"
export BACK_CYAN="\033[0;46;30m"
export BACK_WHITE="\033[0;47;30m"

# bold & background
export BOLD_BACK_BLACK="\033[1;40m"
export BOLD_BACK_RED="\033[1;41;30m"
export BOLD_BACK_GREEN="\033[1;42;30m"
export BOLD_BACK_YELLOW="\033[1;43;30m"
export BOLD_BACK_BLUE="\033[1;44;30m"
export BOLD_BACK_PURPLE="\033[1;45;37m"
export BOLD_BACK_CYAN="\033[1;46;30m"
export BOLD_BACK_WHITE="\033[1;47;30m"

export RST="\033[0m"

export NOTHING="$BOLD_YELLOW""nothing happened 👒$RST"
export W_ARGS="$RED""wrong numbers of args$RST"

# bind -s 'set completion-ignore-case on'

alias gcw='gcc -Wall -Wextra -Werror -g'
alias out='./a.out'

alias gcl='git clone'
alias norm='norminette -R CheckForbiddenSourceHeader'
alias c='clear'
alias l='ls'

alias set_rc='cp -f ~/42/.shortcut ~/.'
alias get_rc='cp -f ~/.shortcut ~/42/.'

# change to function "~/.$0rc" 
# shell_name=$(ps -ef | grep $$ | grep -v grep | head -1 | awk '{print $8}')
shell_name=$(ps -p $$ | tail -n 1 | awk '{print $4}')

function cfga()
{
	if [[ $shell_name == "zsh" ]];
	then
		if [ -f "$FILE/.zshrc" ]; then
			code ~/.zshrc
		fi
	fi
	if [[ $shell_name == "bash" ]];
	then
		if [ -f "$FILE/.bashrc" ]; then
			code ~/.bashrc
		fi
	fi
	code ~/.shortcut
}

function start()
{
	if [[ $shell_name == "zsh" ]];
	then
		if [ -f "/home/gael/.zshrc" ]; then
			source ~/.zshrc
			echo -e $BACK_GREEN" ZSH is restarted "$RST
		fi
	fi
	if [[ $shell_name == "bash" ]];
	then
		if [ -f "/home/gael/.bashrc" ]; then
			source ~/.bashrc
			echo -e $BACK_GREEN" BASH is restarted "$RST
		fi
	fi
}

# shortcut
function poush_out()
{
	if [[ $# == 1 ]]
	then
		git add .
		git commit -m $1
		git push
	else
		echo -e W_ARGS
	fi
}

function poush()
{
	if [[ $# == 1 ]]
	then
		date
		cd ~/42
		cp ~/.config/Code/User/snippets/c.json .
		cp ~/.config/Code/User/snippets/shellscript.json . 
		cp -f ~/.shortcut .
		git add .
		git commit -m $1
		git push
	else
		echo "missing arg"
	fi
}

function pull()
{
	date
	git pull && cp -f ~/42/c.json ~/.config/Code/User/snippets/ && cp -f ~/42/shellscript.json ~/.config/Code/User/snippets/ && cp -f ~/42/.shortcut ~/
}

function cfg()
{
	code ~/.shortcut
	# a=$(pwd)
	# cd && code .shortcut
	# cd $a
}

function cpl()
{
	rm -f *.gch
	rm -f */*.gch
	gcc -Wall -Wextra -Werror $@ && ./a.out
}

function cpla()
{
	if [[ $# != 1 ]]; then
		echo -e $W_ARGS
	elif [[ "$#" == 1 ]]; then
		if [ "${1/-*t}" != $1 ]; then
			rm -f *.gch
		fi
		if [ "${1/-*T}" != $1 ]; then
			rm -f */*.gch
		fi
		if [ "${1/-*m}" != $1 ]; then
			make
		fi
		if [ "${1/-*t}" != $1 ]; then
			rm -f *.gch
		fi
		if [ "${1/-*T}" != $1 ]; then
			rm -f */*.gch
		fi
	elif [[ "$#" == 0 ]]; then
		gcc -Wall -Wextra -Werror -g *.c *.h && ./a.out
	fi

}
# if [ "${1/-*s}" != $1 ]; then
# 	gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c *.h */*.c */*.h && ./a.out
# else
# 	gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c *.h && ./a.out
# fi

# with args
function refresh()
{
	if [[ "$#" > 0 ]]; then
		while true; do
			rm -f *.gch
			gcc -Wall -Wextra -Werror $@ && ./a.out
			sleep 1
		done
	else
		echo "$RED""no args $RST"
	fi
}

# all
function refresha()
{
	if [[ $# == 0 ]];
	then
		while true; do
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out
			sleep 1
		done
	else
		while true; do
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out $@
			sleep 1
		done
	fi
}

# all sub
function refresh_all()
{
	if [[ $# == 0 ]];
	then
		while true; do
			rm -f *.gch && rm -f */*.gch
			gcc -Wall -Wextra -Werror *.c *.h */*.c */*.h && ./a.out
			sleep 1
		done
	else
		while true; do
			rm -f *.gch && rm -f */*.gch
			gcc -Wall -Wextra -Werror *.c *.h */*.c */*.h && ./a.out $@
			sleep 1
		done
	fi
}

# norm refresh
function refreshn()
{
	if [[ $# == 0 ]]
	then
		while true; do
			echo -e "$BACK_GREEN\n	----- ----- NORMINETTE ----- ----- $RESET" 
			norminette -R CheckForbiddenSourceHeader
			sleep 1
		done
	else
		echo -e $W_ARGS
	fi
}

function clr()
{
	if [[ "${1/-f}" != $1 ]]; then
		rm -f *.gch
		rm -f a.out
		rm -rf */.vscode
		rm -rf .vscode
		clear
	else
		echo "are you sure to clear :\n_ file.gch\n_ a.out\n_ .vscode\n?\n"
		read -r answer
		if [[ $answer == "yes" || $answer == "y" ]]; then
			rm -f *.gch
			rm -f a.out
			rm -rf .vscode
			clear
		else
			echo -e $NOTHING
		fi
	fi
}

function crt()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -d "$1" ]]; then
			mkdir $1 && cd $1 && code . 
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}

function crtf()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -f "$1" ]]; then
			touch $1 && code $1 
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}

function is_in()
{
	if [[ $# == 2 ]]
	then
		big=$1
		needle=$2
		if [[ "${big/$needle}" == $big ]]
		then
			echo "nothing"
		else
			echo "something here"
		fi
	else
		echo -e $W_ARGS
	fi
}

function is_number()
{
	if ! [[ $1 =~ '^[0-9]+$' ]]; 
	then 
		echo "error: Not a number" 
		# >&2; exit 1 
	fi
}

function print_arr()
{
	arr=$1
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function nds()
{
	if [[ $# == 1 || $# == 2 ]]; then
		big=$1
		needle=".js"
		if [[ "${big/$needle}" == $big ]]
		then
			ext=".js"
			file=$1$ext
		else
			file=$1
		fi

		if [[ -f $file ]]; then
			echo -e "$BOLD_YELLOW$file$RST exist and it is launched with $BOLD_GREEN""node$RST"
			if [[ $2 == "-c" ]]; then
				echo -e "and $BOLD_CYAN""vscode$RST"
				code $file
			fi
			node $file
		else
			echo -e "$BOLD_YELLOW$file$RST does not exist, do you want to create it ? $BOLD_YELLOW(y/n)$RST"
			echo -e "$RED(!) Check the path before to answer the question (!)$RST"
			echo -e "$RED--->$RST $(pwd)$RST"
			read answer
			if [[ $answer == "y" || $answer == "yes" ]]; then
				touch $file
				echo -e "$BOLD_YELLOW$file$RST	 created"
				if [[ $2 == "-c" ]]; then
					echo -e "$BOLD_YELLOW$file$RST is launch with $BOLD_BLUE""node$RST"
					code $file
				fi
			else
				echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
			fi
		fi
	else
		echo -e $W_ARGS
	fi
}

function rmv()
{
	if [[ $# == 1 ]]
	then
		if [[  -f $1 ]]
		then
			rm -f $1
		elif [[ -d $1 ]]
		then
			rm -rf $1
		else 
			echo "$1 is not a file or a directory, are you sure to delete it ?"
			read answer
			if [[ answer == 'y' || answer == 'yes' ]]
			then
				rm -rf $1
			else
				echo -e $NOTHING
			fi
		fi
	elif [[ $# == 2 ]]
	then
		if [[ $1 == "-f" || $2 == "-f" ]]
		then
			echo "x"
		fi
	else
		echo -e $W_ARGS
	fi
}

function high_mem()
{
	line="$(top -bn1 -o +%MEM | head -n 8 | tail -1)"
	pid="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $1}')"
	task_name="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $12}')"
	echo -e $line
	if [[ $task_name != "plasmashell" && $task_name != "kwin_x11" ]]
	then
		echo -e "$BOLD_RED "$task_name" was killed $RST"
		kill -9 $pid
	else
		echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
	fi
}

function vmem()
{
	if [ -z "$1" ]
	then
		# echo "5 most task memory used"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vcpu()
{
	if [ -z "$1" ]
	then
		# echo "5 most task memory used"
		top -bn1 -o %CPU | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vstat()
{
	if [ -z "$1" ]
	then
		# "5 most task memory used"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n 12 | tail -7
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
	fi
}


function print_title()
{
	escp="\e["
	wrt=";3"
	echo -e $escp"2"$wrt$2"m>"$escp"0"$wrt$2"m>"$escp"1"$wrt$2"m>" $1 $escp"1"$wrt$2"m<"$escp"0"$wrt$2"m<"$escp"2"$wrt$2"m<$RST"
	# echo -e "\e[2;3$2m"">""\e[0;3$2m"">""\e[1;3$2m"">" $1 "\e[1;3$2m""<""\e[0;3$2m""<""\e[2;3$2m""<$RST" 

}

function search()
{
	if [ -z "$  1" ]
	then
		echo "first arg missing"
	else
		grep -riIon $1
		if [[ $(grep -riIon $1 | wc -l) == 1 ]]
		then
			a="$(grep -riIon $1 | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | awk -F ":" '{print $1":"$2}')"
			code -g $a
		else
			echo -e $BACK_RED" $(grep -riIon $1 | wc -l) results, expected : 1 "$RST
			# b="$(tr -d \\033 $a :$1)"
			# echo -e $b
		fi
	fi
}


# courses
function display_js()
{
	echo -e "$BACK_YELLOW   document   $RESET" "$BACK_WHITE""       .querySelector( $RESET" "$BACK_PURPLE    '#menu'     $RESET" "$BACK_WHITE) $RESET\n"
	echo -e "$RESET explained :"
	echo -e "$BACK_YELLOW the web page $RESET" "$BACK_WHITE"" .the search function( $RESET" "$BACK_PURPLE 'tag selector' $RESET" "$BACK_WHITE) $RESET"
	# event example and list
}

function display_port()
{
	echo -e "$BOLD_GREEN""IP address (format: $BOLD_YELLOW""x.x.x.x$BOLD_GREEN, x between $BOLD_YELLOW""0 and 255$BOLD_GREEN)"
	echo -e "$BOLD_CYAN        network id ─┴─┘$BOLD_PURPLE"" └─┴─ host id"
	echo -e "$GREEN""is a sequence of number that is connected to a computer network, used for communications."
	echo -e "2 main functions of am IP address: "
	echo -e "_ $BOLD_YELLOW""identification of a computer in a network$GREEN"
	echo -e "_ $BOLD_YELLOW""localisation of the computer$RESET"

	echo -e ""
	echo -e "$WHITE""CMD display port: $BOLD_WHITE""netstat -lntup"
	echo -e ""
	echo -e "$YELLOW""22    : $BOLD_GREEN""SSH$GREEN (Secure Shell)                           : $RESET"
	echo -e "$YELLOW""25    : $BOLD_GREEN""SMTP$GREEN (Simple Mail Transfer)                  : $RESET"
	echo -e "$YELLOW""143   : $BOLD_GREEN""IMAP$GREEN (Internet Message Access Protocol)      : $RESET"
	echo -e "$YELLOW""53    : $BOLD_GREEN""DNS$GREEN (Domain Name System)                     : use to identify computers through internet and associate Domain Name with other information$RESET"
	echo -e "$YELLOW""5353  : $BOLD_GREEN""mDNS$GREEN (multicast Domain Name System)          : $RESET"
	echo -e "$YELLOW""111   : $BOLD_GREEN""Portmapper$GREEN                                   : provides other ports where services are running$RESET"
	echo -e "$YELLOW""123   : $BOLD_GREEN""NTP$GREEN (Network Time Protocol)                  : use to $BOLD_YELLOW""synchronise clock$GREEN  between computer systems $RESET"
	echo -e "$YELLOW""80    : $BOLD_GREEN""HTTP$GREEN (HyperText Transfert Protocol)          : use to transfert hypermedia document (ex: HTML for $BOLD_YELLOW""website$GREEN)$RESET"
	echo -e "$YELLOW""443   : $BOLD_GREEN""HTTPS$GREEN (HyperText Transfert Protocol Secure)  : the same but it's $BOLD_YELLOW""encrypted with SSL$GREEN (so it use the HTTP)$RESET"
	echo -e "$YELLOW""631   : $BOLD_GREEN""IPP$GREEN (Internet Printing Protocol)             : use between clients devices and $BOLD_YELLOW""printers$RESET"
	echo -e ""
}



# part test
function t1()
{
	# see all the args
	for var in "$@"
	do
		echo "$var"
	done
}

function t2()
{
	a="some long string"
    b="ri"
	# return the rest of the occurence
	echo $a | grep -o "$b.*"
}

function t3()
{
	# get args after the second
	echo "${@:2}"
	# get args after the third
	echo "${@:3}"
}

function t4()
{
	# get nbr of args
	echo "$#"
}

function t5()
{
	# check if there is something like "- * s"
	str="-ms"
	a1="${str/e}"
	a2="${str/m}"
	if [ "${str/e}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
	if [ "${str/-*s}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
}

function t6()
{
	# check if there is something like "- * m" in the 1st arg
	if [[ "${1/-*m}" != $1 ]]; then
		echo "there is m"
	else
		echo "nothing"
	fi
}

function t7()
{
	echo "${BASH_SOURCE}"
	echo "${BASH_SOURCE}"
}

function t8()
{
	if [ -z "$1" ]
	then
		echo "No argument suppliedwith" '$1'
	fi

	echo $(if [[ $(free | wc -l) > 1 ]]; then echo on; else echo off; fi)
}

function t9()
{
	tmp='%n@%m'
	tmp='%u'
	echo ${(%)tmp}
	
	# bash
	# tmp=$(set +x; (PS4='+.\u@\h'; set -x; :) 2>&1); tmp=${tmp#*.}; echo ${tmp%:}
}

function t10()
{
	# SPLIT

	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$text"

	#Count the total words
	echo "There are ${#strarr[*]} words in the text."

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
	printf "$val\n"
	done
}

# google-chrome-stable https://pythontutor.com/c.html#mode=edit

function t11()
{
	if test -f "*.c"; then
		echo "ok"
	else
		echo "nothing"
	fi
}

function t12()
{
	FILES="/bin/*"
	for file in /mnt/nfs/homes/ggosse/42/*
	do
		dir="$(dirname "${file}")"
		filename="$(basename "${file}")"
		if [[ -f $file ]]; then
			echo -e "$GREEN /$filename"
		elif [[ -d $file ]]; then
			echo -e "$CYAN /$filename"
		else
			echo -e "$YELLOW /$filename"
		fi
	done
}

#
function t14()
{
	FILES="/mnt/nfs/homes/ggosse/42/cursus/gnl/*"
	for filename in /mnt/nfs/homes/ggosse/42/cursus/gnl/*; do
		echo -e "$CYAN here $filename";
	done
}

# call multiple web page
function t15()
{
	a=1
	while true; do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$a/fr.subject.pdf
		let "a+=1"
		if [[ $a > 10 ]]; then
			break;
		fi
	done
}

function t16()
{
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/1/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/2/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/3/fr.subject.pdf
    # google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/4/fr.subject.pdf
	start=57300
	step=20

	let "end=$start+$step-1"
	for i in {$start..$end}
	do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$i/fr.subject.pdf
		let "i+=1"
	done
}



# function t13()
# {
# 	each file
# 	for file in "$/."; do
# 		if [ -d $file ]
# 		then
# 				# do something directory-ish
# 		else
# 				if [ "$file" == "*.txt" ]       #  this is the snag
# 				then
# 						# do something txt-ish
# 				fi
# 		fi
# 	done;
# }


function t14()
{
	if [[ $# > 1 ]]
	then
		echo -e $RED"something for example$RST"
		echo -e 'last return        : $_     ' $_
		echo -e 'return value       : $?     ' $?
		echo -e 'first argument     : $1     ' $1
		echo -e 'second argument    : $2     ' $2
		echo -e 'all of argument    : $@     ' $@
		echo -e 'number of argument : $#     ' $#
		echo -e 'EUID               : ${EUID} '${EUID}
	else
		echo $RTRE
	fi
}


# SPLIT
function t15()
{
	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	# IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$1"

	#Count the total words
	echo -e "$CYAN${#strarr[*]}$RST"
	echo -e "$RED${strarr[*]}$RST"

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
		printf "$val\n"
	done
}

# refresh with a bash script
function refresht()
{
	interrupt="false"
	trap '$interrupt="true"' INT
	if [[ $# == 1 ]]; then
		source ~/.bashrc && $1
		echo -e "$BACK_CYAN ----- START ----- $RST"
		export TEST_FUNCTION=$1
		sleep 2
		refresht
	elif [[ $TEST_FUNCTION && $interrupt == "false" ]]; then
		source ~/.bashrc && $TEST_FUNCTION
		echo -e "$BACK_GREEN ----- IN TEST ----- $RST"
		sleep 2
		refresht
	fi
}

# catch a sigint
function t16()
{
	trap 'echo -e "\nhey"' INT
	# for ((n=20; n; n--))
	# do
	# 	sleep 1
	# done
}

# open vscode after a grep in a certain file and line number
function t17()
{
	# r recursive ins subfolder
	# i insensitive case
	# n at number line xxx
	# o word exact match 
	if [[ $# == 1 ]]; then
		result=`grep -rinl $1 --exclude-dir=node_modules`
		# echo $result
		read -a arr <<< "$result"
		echo $arr | '{gsup($1,'')}'
		# code $arr 
		# echo -e "$RED${arr[*]}$RST"
		# echo -e "$CYAN${#arr[*]}$RST"
		# for val in "${arr[@]}";
		# do
		# 	printf "$val\n"
		# done
	else
		printf "something wrong"
	fi
}

# test	is in	in a condition
function t18()
{
	# if [[ is_in ]]; then
	# 	echo "a"
	# else
	# 	echo "b"
	# fi
	echo "not finish"
}

# call multiple times a bash function
function t19 ()
{

	# start=1
	# end=20

	# for i in {1..7}
	# do
	# 	print_title "GNL" $i
	# 	let "i+=1"
	# done

	print_title "GNL" 7 # Red
	print_title "GNL" 3 # Green
	print_title "GNL" 4 # Yellow
	print_title "GNL" 1 # Orange or Blue
	print_title "GNL" 5 # Blue
	print_title "GNL" 6 # Cyan
	print_title "GNL" 2 # White
}

function t20()
{
	arr=()
	arr+=("a")
	arr+=("b")
	arr+=("c")
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function t21()
{
	arr=("AC" "TV" "Mobile" "Fridge" "Oven" "Blender")
	arr+=("Dish Washer")
	arr+=("Cat")
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function t22()
{
	name_page=()
	answer=""
	echo "How many pages do you want ? (digits) "
	read answer
	if [[ $answer > 0 || $answer < 31 ]]
	then
		if [[ $1 == "1" ]]
		then
			name_page+="one"
		else
			echo "name each page"
			start=1
			for ((n=1; n<=$answer; n++))
			do
				echo "	page $n = ... ?"
				read a
				name_page+=($a)
			done
		fi
		# for item in "${name_page[@]}"
		# do
		# 	echo $item
		# done
	else
		echo "error: $answer is not a number or dot not belongs to this interval [1..30]";
	fi
}

function t23()
{
	# REPLACE A CHAR BY ANOTHER IN A STRING
	item="browser-refresh"
	echo $item
	var_name=$(echo "$item" | tr - _)
	echo $var_name
}

function t24()
{
	item='exemple'
	home_page="${item}"
	echo $home_page
}

function t25()
{
	# test if args exist
	if [ $# -eq 0 ]
	then
		echo "No arguments supplied with" '$#'

	fi

	# test if arg 2 exist
	if [ -z "$1" ]
	then
		echo "first arg missing"
	fi
}

function split()
{
	if [[ $# == 0 ]]
	then
		echo "Missing args, the first must be the string and the second will be the delimiter"
	elif [[ $# == 1 ]]
	then
		text=$1
		IFS=' '
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	elif [[ $# == 2 ]]
	then
		text=$1
		IFS=$2
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	fi
}

function t26()
{
	# - Position the Cursor:
	# \033[<L>;<C>H
	# 	Or
	# \033[<L>;<C>f
	# puts the cursor at line L and column C.
	# - Move the cursor up N lines:
	# \033[<N>A
	# - Move the cursor down N lines:
	# \033[<N>B
	# - Move the cursor forward N columns:
	# \033[<N>C
	# - Move the cursor backward N columns:
	# \033[<N>D

	# - Clear the screen, move to (0,0):
	# \033[2J
	# - Erase to end of line:
	# \033[K

	# - Save cursor position:
	# \033[s
	# - Restore cursor position:
	# \033[u

	# echo -e "\033[<5>B X"
	# echo -en "\033[s\033[7B\033[1;34m 7 lines down violet \033[u\033[0m"
	# echo -en "\033[s\033[7A\033[1;32m 7 lines up green \033[u\033[0m"	

	tput clear      # clear the screen

	tput cup 3 15   # Move cursor to screen location X,Y (top left is 0,0)

	tput setaf 3    # Set a foreground colour using ANSI escape
	echo "XYX Corp LTD."
	tput sgr0

	tput cup 5 17
	tput rev        # Set reverse video mode (background)
	echo " M A I N - M E N U "
	tput sgr0       # stop background color

	tput cup 7 15; echo "1. User Management"
	tput cup 8 15; echo "2. Service Management"
	tput cup 9 15; echo "3. Process Management"
	tput cup 10 15; echo "4. Backup"

	tput bold       # Set bold mode (red)
	tput cup 12 15
	read -p "Enter your choice [1-4] " choice

	tput clear
	tput sgr0
	tput rc
}

function t27()
{
	# get position of the cursor
	exec < /dev/tty
	oldstty=$(stty -g)
	stty raw -echo min 0
	# on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	# tput u7 > /dev/tty    # when TERM=xterm (and relatives)
	IFS=';' read -r -d R -a pos
	stty $oldstty
	# change from one-based to zero based so they work with: tput cup $row $col
	row=$((${pos[0]:2} - 1))    # strip off the esc-[
	col=$((${pos[1]} - 1))
	echo $row
	echo $col
}

function t28()
{
	perc=0
	
	sleep 1
	tput clear

	tput cup 0 0; echo "-"
	tput cup 0 8; echo "-"

	tput cup 0 10; echo "["

	tput setaf 1
	tput rev
	tput cup 0 11; echo "          "
	tput sgr0
	
	# tput setaf 1
	tput cup 0 21; echo "]"

	tput sgr0
	sleep 1
	while [[ $perc -lt 101 ]]
	do
		if [[ $perc -ge 0 && $perc -lt 10 ]]
		then
			tput cup 0 4; echo "$perc %"
		elif [[ $perc -ge 10 && $perc -lt 100 ]]
		then
			tput cup 0 3; echo "$perc %"
		else [[ $perc -ge 100 && $perc -lt 1000 ]]
			tput cup 0 2; echo "$perc %"
		fi
		if [[ $perc -lt 100 ]]
		then
			tput setaf 2
			tput rev
			tput cup 0 $((($perc/10)+11)); echo " "
			tput sgr0
		fi

		let "perc+=2"
		sleep 0.15
	done
}



#	 - 100% - [1234567890]
#	0123456789012345678901
#	0000000000111111111122
#	upgrade colors
#	norminette display lines and numbers of cols
#	code grep file:line

# m4 precompile header


#define malloc(...) NULL

#define prinT(str, __VA_ARG__)\
	#ifdef TEST\
		# printf(str, ##VA_ARG);\
	#endif\

# 🐒🏴‍☠🍖
# 🏴 ☠️
# 👒⚔🏴‍☠️🌊
# 🐲
# 🦈