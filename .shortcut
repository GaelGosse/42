#!/bin/sh

# lite
BLACK="\033[0;30m"
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
PURPLE="\033[0;35m"
CYAN="\033[0;36m"
WHITE="\033[0;37m"

# bold color
BOLD_BLACK="\033[1;30m"
BOLD_RED="\033[1;31m"
BOLD_GREEN="\033[1;32m"
BOLD_YELLOW="\033[1;33m"
BOLD_BLUE="\033[1;34m"
BOLD_PURPLE="\033[1;35m"
BOLD_CYAN="\033[1;36m"
BOLD_WHITE="\033[1;37m"

# background
BACK_BLACK="\033[0;40m"
BACK_RED="\033[0;41;30m"
BACK_GREEN="\033[0;42;30m"
BACK_YELLOW="\033[0;43;30m"
BACK_BLUE="\033[0;44;30m"
BACK_PURPLE="\033[0;45;37m"
BACK_CYAN="\033[0;46;30m"
BACK_WHITE="\033[0;47;30m"

RST="\033[0m"


alias gcw='gcc -Wall -Wextra -Werror -g'
alias out='./a.out'

alias gcl='git clone'
alias norm='norminette -R CheckForbiddenSourceHeader'
alias c='clear'
alias lt='ls -pFhal '

alias z='source ~/.zshrc'
alias b='source ~/.bashrc'

alias set_rc='cp -f ~/42/.shortcut ~/.'
alias get_rc='cp -f ~/.shortcut ~/42/.'

# shortcut
function poush_out()
{
	if [[ $# == 1 ]]
	then
		git add .
		git commit -m $1
		git push
	else
		echo "an argument is missing"
	fi
}

function poush()
{
	date
	# take .shortcut at ~/.
	cp ~/.config/Code/User/snippets/c.json ~/42/ && cp -f ~/.shortcut ~/42/
	git add .
	git commit -m $1
	git push
}

function pull()
{
	date
	git pull && cp -f ~/42/ ~/.config/Code/User/snippets/c.json && cp -f ~/42/.shortcut ~/
}

function cfg()
{
	code ~/.shortcut
	# a=$(pwd)
	# cd && code .shortcut
	# cd $a
}

function cpl()
{
	rm -f *.gch
	rm -f */*.gch
	gcc -Wall -Wextra -Werror $@ && ./a.out
}

function cpla()
{
	if [[ "$#" > 1 ]]; then
		echo "something wrong with args"
	elif [[ "$#" == 1 ]]; then
		if [ "${1/-*t}" != $1 ]; then
			rm -f *.gch
		fi
		if [ "${1/-*T}" != $1 ]; then
			rm -f */*.gch
		fi
		if [ "${1/-*m}" != $1 ]; then
			make
		fi
		if [ "${1/-*s}" != $1 ]; then
			gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c *.h */*.c */*.h && ./a.out
		else
			gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c *.h && ./a.out
		fi
		if [ "${1/-*t}" != $1 ]; then
			rm -f *.gch
		fi
		if [ "${1/-*T}" != $1 ]; then
			rm -f */*.gch
		fi
	elif [[ "$#" == 0 ]]; then
		gcc -Wall -Wextra -Werror -g *.c *.h && ./a.out
	fi

}

# with args
function refresh()
{
	if [[ "$#" > 0 ]]; then
		while true; do
			rm -f *.gch
			gcc -Wall -Wextra -Werror $@ && ./a.out
			sleep 1
		done
	else
		echo "no args"
	fi
}

# all
function refresha()
{
	while true; do
		rm -f *.gch
		gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c *.h && ./a.out
		sleep 1
	done
}

# all sub
function refresh_all()
{
	while true; do
		rm -f *.gch && rm -f */*.gch
		gcc -Wall -Wextra -Werror *.c *.h */*.c */*.h && ./a.out
		sleep 1
	done
}

# norm refresh
function refreshn()
{
	while true; do
		echo -e "$BACK_GREEN\n	----- ----- NORMINETTE ----- ----- $RESET" 
		norminette -R CheckForbiddenSourceHeader
		sleep 1
	done
}

function clr()
{
	if [[ "${1/-f}" != $1 ]]; then
		rm -f *.gch
		rm -f a.out
		rm -rf .vscode
		clear
	else
		echo "are you sure to clear :\n_ file.gch\n_ a.out\n_ .vscode\n?\n"
		read -r answer
		if [[ $answer == "yes" || $answer == "y" ]]; then
			rm -f *.gch
			rm -f a.out
			rm -rf .vscode
			clear
		else
			echo "nothing happens"
		fi
	fi
}

function crt()
{
	if [[ ! -d "$1" ]]; then
		mkdir $1 && cd $1 && code . 
	else
		echo "$1 already exist"
	fi
}

function crtf()
{
	if [[ ! -f "$1" ]]; then
		touch $1 && code $1 
	else
		echo "$1 already exist"
	fi
}




# part test
function t1()
{
	# see all the args
	for var in "$@"
	do
		echo "$var"
	done
}

function t2()
{
	a="some long string"
    b="ri"
	# return the rest of the occurence
	echo $a | grep -o "$b.*"
}

function t3()
{
	# get args after the second
	echo "${@:2}"
	# get args after the third
	echo "${@:3}"
}

function t4()
{
	# get nbr of args
	echo "$#"
}

function t5()
{
	# check if there is something like "- * s"
	str="-ms"
	a1="${str/e}"
	a2="${str/m}"
	if [ "${str/e}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
	if [ "${str/-*s}" == $str ]; then
		echo "nothing"
	else
		echo "something here"
	fi
}

function t6()
{
	# check if there is something like "- * m" in the 1st arg
	if [[ "${1/-*m}" != $1 ]]; then
		echo "there is m"
	else
		echo "nothing"
	fi
}

function t7()
{
	echo "${BASH_SOURCE}"
	echo "${BASH_SOURCE}"
}

function t8()
{
	echo $(if [[ $(free | wc -l) > 1 ]]; then echo on; else echo off; fi)
}

function t9()
{
	tmp='%n@%m'
	tmp='%u'
	echo ${(%)tmp}
	
	# bash
	# tmp=$(set +x; (PS4='+.\u@\h'; set -x; :) 2>&1); tmp=${tmp#*.}; echo ${tmp%:}
}

function t10()
{
	# SPLIT

	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$text"

	#Count the total words
	echo "There are ${#strarr[*]} words in the text."

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
	printf "$val\n"
	done
}

# google-chrome-stable https://pythontutor.com/c.html#mode=edit

function t11()
{
	if test -f "*.c"; then
		echo "ok"
	else
		echo "nothing"
	fi
}

function t12()
{
	FILES="/bin/*"
	for file in /mnt/nfs/homes/ggosse/42/cursus/gnl/*
	do
		dir="$(dirname "${file}")"
		filename="$(basename "${file}")"
		if [[ -f $file ]]; then
			echo -e "$GREEN /$filename"
		elif [[ -d $file ]]; then
			echo -e "$CYAN /$filename"
		else
			echo -e "$YELLOW /$filename"
		fi
	done
}

function t14()
{
	FILES="/mnt/nfs/homes/ggosse/42/cursus/gnl/*"
	for filename in /mnt/nfs/homes/ggosse/42/cursus/gnl/*; do
		echo -e "$CYAN here $filename";
	done
}

function t15()
{
	a=1
	while true; do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$a/fr.subject.pdf
		let "a+=1"
		if [[ $a > 10 ]]; then
			break;
		fi
	done
}

function t16()
{
		# google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/1/fr.subject.pdf
		# google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/2/fr.subject.pdf
		# google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/3/fr.subject.pdf
		# google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/4/fr.subject.pdf
	start=57300
	step=20

	let "end=$start+$step-1"
	for i in {$start..$end}
	do
		google-chrome-stable https://cdn.intra.42.fr/pdf/pdf/$i/fr.subject.pdf
		let "i+=1"
	done
}

# course
function display_js()
{
	echo -e "$BACK_YELLOW   document   $RESET" "$BACK_WHITE""       .querySelector( $RESET" "$BACK_PURPLE    '#menu'     $RESET" "$BACK_WHITE) $RESET\n"
	echo -e "$RESET explained :"
	echo -e "$BACK_YELLOW the web page $RESET" "$BACK_WHITE"" .the search function( $RESET" "$BACK_PURPLE 'tag selector' $RESET" "$BACK_WHITE) $RESET"
	# event example and list
}

function display_port()
{
	echo -e "$BOLD_GREEN""IP address (format: $BOLD_YELLOW""x.x.x.x$BOLD_GREEN, x between $BOLD_YELLOW""0 and 255$BOLD_GREEN)"
	echo -e "$BOLD_CYAN        network id ─┴─┘$BOLD_PURPLE"" └─┴─ host id"
	echo -e "$GREEN""is a sequence of number that is connected to a computer network, used for communications."
	echo -e "2 main functions of am IP address: "
	echo -e "_ $BOLD_YELLOW""identification of a computer in a network$GREEN"
	echo -e "_ $BOLD_YELLOW""localisation of the computer$RESET"

	echo -e ""
	echo -e "$WHITE""CMD display port: $BOLD_WHITE""netstat -lntup"
	echo -e ""
	echo -e "$YELLOW""22    : $BOLD_GREEN""SSH$GREEN (Secure Shell)                           : $RESET"
	echo -e "$YELLOW""25    : $BOLD_GREEN""SMTP$GREEN (Simple Mail Transfer)                  : $RESET"
	echo -e "$YELLOW""143   : $BOLD_GREEN""IMAP$GREEN (Internet Message Access Protocol)      : $RESET"
	echo -e "$YELLOW""53    : $BOLD_GREEN""DNS$GREEN (Domain Name System)                     : use to identify computers through internet and associate Domain Name with other information$RESET"
	echo -e "$YELLOW""5353  : $BOLD_GREEN""mDNS$GREEN (multicast Domain Name System)          : $RESET"
	echo -e "$YELLOW""111   : $BOLD_GREEN""Portmapper$GREEN                                   : provides other ports where services are running$RESET"
	echo -e "$YELLOW""123   : $BOLD_GREEN""NTP$GREEN (Network Time Protocol)                  : use to $BOLD_YELLOW""synchronise clock$GREEN  between computer systems $RESET"
	echo -e "$YELLOW""80    : $BOLD_GREEN""HTTP$GREEN (HyperText Transfert Protocol)          : use to transfert hypermedia document (ex: HTML for $BOLD_YELLOW""website$GREEN)$RESET"
	echo -e "$YELLOW""443   : $BOLD_GREEN""HTTPS$GREEN (HyperText Transfert Protocol Secure)  : the same but it's $BOLD_YELLOW""encrypted with SSL$GREEN (so it use the HTTP)$RESET"
	echo -e "$YELLOW""631   : $BOLD_GREEN""IPP$GREEN (Internet Printing Protocol)             : use between clients devices and $BOLD_YELLOW""printers$RESET"
	echo -e ""
}


# function t13()
# {
# 	each file
# 	for file in "$/."; do
# 		if [ -d $file ]
# 		then
# 				# do something directory-ish
# 		else
# 				if [ "$file" == "*.txt" ]       #  this is the snag
# 				then
# 						# do something txt-ish
# 				fi
# 		fi
# 	done;
# }

function t14()
{
	echo ${EUID}
}


function t15()
{
	# SPLIT

	#Define the string value
	text="Welcome to LinuxHint"

	# Set space as the delimiter
	# IFS=' '

	#Read the split words into an array based on space delimiter
	read -a strarr <<< "$1"

	#Count the total words
	echo -e "$CYAN${#strarr[*]}$RST"
	echo -e "$RED${strarr[*]}$RST"

	# Print each value of the array by using the loop
	for val in "${strarr[@]}";
	do
		printf "$val\n"
	done
}

function refresht()
{
	interrupt="false"
	trap '$interrupt="true"' INT
	if [[ $# == 1 ]]; then
		source ~/.bashrc && $1
		echo -e "$BACK_CYAN ----- START ----- $RST"
		export TEST_FUNCTION=$1
		sleep 2
		refresht
	elif [[ $TEST_FUNCTION && $interrupt == "false" ]]; then
		source ~/.bashrc && $TEST_FUNCTION
		echo -e "$BACK_GREEN ----- IN TEST ----- $RST"
		sleep 2
		refresht
	fi
}

function t16()
{
	trap 'echo "hey"' INT
	for ((n=20; n; n--))
	do
		sleep 1
	done
}

function t17()
{
	# r recursive ins subfolder
	# i insensitive case
	# n at number line xxx
	# o word exact match 
	if [[ $# == 1 ]]; then
		result=`grep -rinl $1 --exclude-dir=node_modules`
		# echo $result
		read -a arr <<< "$result"
		echo $arr | '{gsup($1,'')}'
		# code $arr 
		# echo -e "$RED${arr[*]}$RST"
		# echo -e "$CYAN${#arr[*]}$RST"
		# for val in "${arr[@]}";
		# do
		# 	printf "$val\n"
		# done
	else
		printf "something wrong"
	fi
}

# upgrade colors
# norminette display lines and numbers of cols
# code grep file:line

# m4 precompile header


#define malloc(...) NULL

#define prinT(str, __VA_ARG__)\
	#ifdef TEST\
		# printf(str, ##VA_ARG);\
	#endif\
